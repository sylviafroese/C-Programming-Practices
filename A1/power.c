//------------------------------------------------------------------// NAME: Sylvia Froese// STUDENT NUMBER: 6203180// COURSE: COMP 2160, SECTION: A02// INSTRUCTOR: Yang Wang// ASSIGNMENT: 1, QUESTION 1//// REMARKS: The purpose of this program is to output how many // multiplication operations are used in each power function// when calculating base^power using different algorithms#include <stdio.h>#define MAX 4//------------------------------------------------------------------// Power1//// PURPOSE: This is a function that calculates the power recursively//          for a given base. the function will multiply the base by//          the number of times of the power value// INPUT PARAMETERS: base, index, *count// base - is a value of a double array, which is the base number// index - is a value of an integer array, which is the power //         (ie. the number of times the base is multiplied by)// count - keeps track of the number of multiples//// OUTPUT PARAMETERS: retValue (double)//// The Power2 function returns a double value, which is base^power//------------------------------------------------------------------  double power1 (double base, int index, int *count)  {    double retValue;  // returns the number of multiples used to calculate the power        // if the given index is 0, then the power returned to the main function is 1    if (index == 0)     {      retValue = 1;    }    else    {      retValue = base * power1( base, index-1, count );      *count = *count + 1;     }		    return retValue;  }  //------------------------------------------------------------------// Power2//// PURPOSE: This is a function that calculates the power recursively by//          a given base. But it does it quicker than Power1. //	    This function finds all the multiples of the given power.//	    Then it uses the power to create fewer multiplications based//	    on the multiples. The number of multiples is equivalent to the//	    number of multiplications that the function uses to calculate the answer.//        // INPUT PARAMETERS: base, index, *count// base - is a value of a double array, which is the base number// index - is a value of an integer array, which is the power //         (ie. the number of times the base is multiplied by)// count - keeps track of the number of multiples//// OUTPUT PARAMETERS: retValue (double)//// The Power2 function returns a double value, which is base^power//------------------------------------------------------------------  double power2 (double base, int index, int *count)  {    double retValue;    double temp;    // if the given index is 0, then the retValue = 1. This if is what stops the recursion       if (index == 0)    {       retValue = 1;    }    else if ( index%2 == 1 )  // checks if index is an odd number    {      retValue = base * power2 (base, index-1, count);      *count = *count + 1;    }    else // retValue is base ^ (1st multiple) x base ^ (2nd multiple) x ... x base ^ (nth multiple)    {      temp = power2 (base, index/2, count );      retValue = temp * temp;      *count = *count +1;    }		    return retValue;  }	 int main() {    int count;    double base[MAX] = { 1.4, 1.3, 1.2, 1.1 };    int  index[MAX] = { 5, 20, 63, 73 };    double   value;        printf("\nTest two algorithms for powering\n\n");    for( int i=0 ; i<MAX ; i++ )    {      count = 0;      value = power1( base[i], index[i], &count );      printf("1: %2.1f^%d = %f, used %d multiples\n", base[i], index[i], value, count);            count = 0;      value = power2( base[i], index[i], &count );      printf("2: %2.1f^%d = %f, used %d multiples\n\n", base[i], index[i], value, count);          }     printf("\nEnd of processing\n\n");     return 0;		 }  